# Effective Java – Minimize Accessibility of Classes and Members

> *Joshua Bloch, Effective Java – Item: Minimize the accessibility of classes and members*

---

## Core Principle

**Make each class or member as inaccessible as possible.**

Reducing accessibility is one of the most important techniques for building **robust, maintainable, and secure APIs**. Every exposed element becomes a permanent obligation to support and document.

---

## Why Minimize Accessibility?

### 1. Encapsulation

* Hides implementation details
* Prevents clients from depending on internal behavior
* Allows internal changes without breaking users

### 2. Reduced Coupling

* Limits dependencies between components
* Makes systems easier to refactor and evolve

### 3. Increased Security

* Prevents accidental or malicious misuse
* Reduces attack surface

### 4. Easier Maintenance

* Smaller public API = fewer compatibility constraints
* Simplifies testing and debugging

---

## Java Access Levels (From Most to Least Restrictive)

| Modifier    | Visibility              |
| ----------- | ----------------------- |
| `private`   | Within the same class   |
| *(default)* | Within the same package |
| `protected` | Package + subclasses    |
| `public`    | Everywhere              |

**Rule of thumb:** Always start with `private` and relax only if required.

---

## Classes and Interfaces

### Top-Level Classes

* Can be `public` or package-private (no modifier)
* Prefer **package-private** unless the class is part of a public API

```java
class HelperUtil { // package-private
    // implementation details
}
```

Making a class `public` commits you to:

* Backward compatibility
* Long-term maintenance

---

## Members (Fields, Methods, Constructors)

### Fields

* **Make fields `private`**
* Never expose mutable fields directly

❌ Bad:

```java
public int size;
```

✅ Good:

```java
private int size;
public int getSize() {
    return size;
}
```

---

### Mutable Objects

Exposing mutable objects breaks encapsulation.

❌ Bad:

```java
public Date startDate;
```

✅ Good (defensive copies):

```java
private final Date startDate;

public Date getStartDate() {
    return new Date(startDate.getTime());
}
```

---

### Methods

* Make methods `private` unless they must be used externally
* Helper methods should almost always be `private`

```java
private void validateInput() {
    // internal logic
}
```

---

### Constructors

* Use restrictive constructors to control instantiation
* `private` constructors are useful for:

  * Utility classes
  * Singleton patterns

```java
private UtilityClass() {
    throw new AssertionError();
}
```

---

## `protected`: Use with Extreme Caution

* `protected` members become part of your **exported API**
* Subclasses may depend on them
* Hard to change or remove later

**Prefer composition over inheritance** to avoid `protected` exposure.

---

## Public APIs: Think Carefully

Once a member is `public`, you:

* Cannot remove it
* Cannot change its behavior freely
* Must support it indefinitely

> Public APIs are forever.

---

## Constants

If constants are part of the API:

```java
public static final int MAX_SIZE = 100;
```

If not:

```java
private static final int BUFFER_SIZE = 8192;
```

---

## Package Design Matters

* Group related classes in the same package
* Use package-private access to share internals safely
* Avoid exposing implementation packages

---

## Common Mistakes

* Making fields public for convenience
* Overusing `protected`
* Exposing internal helper classes
* Returning internal mutable objects

---

## Best Practices Checklist

* [ ] Start with `private`
* [ ] Expose only what clients need
* [ ] Avoid public fields
* [ ] Return defensive copies
* [ ] Prefer package-private over public
* [ ] Be very cautious with `protected`

---

## Key Takeaway

> **A well-designed module hides its implementation details.**

Minimizing accessibility is not about restriction—it is about **freedom to evolve your code safely**.

---

**Reference:** *Effective Java, 3rd Edition – Joshua Bloch*
