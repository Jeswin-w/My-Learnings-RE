# Dereferencing Java Objects

```java
 public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;
    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }
    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }
    public Object pop() {
        if (size == 0)
            throw new EmptyStackException();
        return elements[--size];
    }
    /**
    * Ensure space for at least one more element, roughly
    * doubling the capacity each time the array needs to grow.
    */
    private void ensureCapacity() {
        if (elements.length == size)
            elements = Arrays.copyOf(elements, 2 * size + 1);
    }
 }
 ```

The above code does not dereference the removed objects. These are never garbage collected and can lead to OOM.

The fix for this sort of problem is simple: null out references once they become obsolete. In the case of our Stack class, the reference to an item becomes obsolete as soon as it’s popped off the stack. The corrected version of the pop method looks like this:

```java
 public Object pop() {
    if (size == 0)
        throw new EmptyStackException();
    Object result = elements[--size];
    elements[size] = null; // Eliminate obsolete reference
    return result;
 }
 ```

***The best way to eliminate an obsolete reference is to let the variable that contained
the reference fall out of scope.*** This occurs naturally if you define each variable in
the narrowest possible scope .

## Caches and dereferencing them

Another common source of memory leaks is caches. Once you put an object reference into a cache, it’s easy to forget that it’s there and leave it in the
cache long after it becomes irrelevant. There are several solutions to this problem.

### Using weak hashmap
Weak hash map can be used for caches if the key becomes obselete(dereferenced)
This makes the keys available for gc.

### LinkedhashMap

We can implement a LRU cache by overriding removeEldestEntry
which is the best way to implement a cache

A third common source of memory leaks is listeners and other callbacks.
If you implement an API where clients register callbacks but don’t deregister them
explicitly, they will accumulate unless you take some action. One way to ensure
that callbacks are garbage collected promptly is to store only weak references to
them, for instance, by storing them only as keys in a WeakHashMap