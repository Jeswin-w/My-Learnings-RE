# Avoid Finalizers and Cleaners (Effective Java Summary)

Finalizers and cleaners are mechanisms for performing cleanup actions
before an object is reclaimed by the garbage collector. However,
**Effective Java strongly advises against using them except in very rare
cases**.

## Why to Avoid Finalizers and Cleaners

### 1. **Unpredictable Execution**

Finalizers and cleaners run at the discretion of the garbage collector.\
There is **no guarantee** about: - *When* they will run\
- *Whether* they will run promptly\
- *In extreme cases, whether they run at all*

This makes them unsuitable for managing critical resources like file
handles or database connections.

### 2. **Performance Cost**

Objects with finalizers slow down garbage collection because: - They
require extra processing\
- JVM places them in a special queue\
- A dedicated thread must execute the finalizer

Cleaners are also expensive for similar reasons.

### 3. **Dangerous Behavior**

Finalizers can resurrect objects (bring them back from the dead), which
can cause: - Security vulnerabilities\
- Hard-to-debug issues\
- Unexpected lifecycle extension

This capability is widely considered harmful.

### 4. **Uncaught Exceptions Are Ignored**

If a finalizer throws an exception: - It is silently ignored\
- The program continues running in a potentially corrupt state

This violates normal Java error-handling expectations.

## What to Use Instead

### ✔ **Try-with-resources (Preferred)**

Use for any resource implementing `AutoCloseable`.\
Cleanup is deterministic and reliable.

Example:

``` java
try (BufferedReader reader = new BufferedReader(new FileReader("file.txt"))) {
    // Use resource
}
```

### ✔ **Explicit termination methods**

If you must manage a non-memory resource, provide a method like:

``` java
public void close()
```

and document that the caller must invoke it.

### ⚠ **When Finalizers/Cleaners MAY be Acceptable**

Use them only: 1. As a **safety net** to catch cases where the client
forgets to close the resource (not for primary cleanup). 2. For
**non-critical cleanup**, such as: - Logging - Statistics updates 3. To
manage **native peers** (resources that Java cannot track), but even
then try-with-resources is still preferred.

## Summary

-   Finalizers and cleaners are **slow**, **unpredictable**, and
    **unreliable**.
-   They should be avoided for normal resource management.
-   Prefer try-with-resources and explicit close methods.
-   Use finalizers/cleaners only as a backup safety mechanism or for
    very specialized use cases.
