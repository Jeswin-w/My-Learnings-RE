# Avoid unnecessary Object creation

Object Creation can be expensive if it is done unnecessarily.

 An object can always be reused if it is immutable (Item 17).
 As an extreme examples of what not to do
 ```java
 String s = new String("bikini");  // DON'T DO THIS!

 //Matches creates pattern object everytime 
  static boolean isRomanNumeral(String s) {
    return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"
        + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
 }
```

even for mutable objects we can avoid object creation.

For example, the keySet method of the Map interface returns a Set view of the
Map object, consisting of all the keys in the map. Naively, it would seem that every
call to keySet would have to create a new Set instance, but every call to keySet
on a given Map object may return the same Set instance.

Avoid autoboxing and prefer primitives.

## This doesn't mean all objects should be reused.
For normal objects (strings, lists, simple classes):

* Creating objects is cheap

* Garbage collection is fast

Pooling adds unnecessary complexity
Problems with object pools:

* More code to write and maintain

* More memory used to store the pool

* Harder to make thread-safe

* Slower than letting the JVM allocate new objects

* Easy to introduce bugs (leaks, stale objects)

Object pools make sense when objects are very expensive to create.

Example:

    Database connections

    Thread pools

    Network sockets

    Big buffers

    Native resources (off-heap, file handles)

    These involve:

        OS calls

        Network operations

        Large memory allocations

Avoid unnecessary object creation, but donâ€™t over-optimize by caching or pooling every object. Only reuse objects when it provides real benefit (immutability or expensive creation).