# Use static factory method instead of creating multiple objects

1. creating objects is expensive
2. in cases where we don’t want to create new objects frequently, we can create a static method that returns an existing or cached instance

**Example:** Boolean never creates new objects

public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}

### Advantages over a constructor:
* reuses object
* has a unique name
* can return a subtype
* can hide implementation classes
* reduces API size and complexity

---

# Static Factory Methods Can Return Subtypes & Hide Implementations

A key advantage of static factory methods is that **they can return any subtype** of their declared return type. Constructors cannot do this — they must always return the exact class they belong to.

This gives powerful flexibility and helps APIs hide implementation details.

---

## 1. Returning any subtype
```java
interface Animal {
    void speak();
}

class Dog implements Animal {
    @Override
    public void speak() { System.out.println("Woof"); }
}

class Cat implements Animal {
    @Override
    public void speak() { System.out.println("Meow"); }
}

class Animals {
    public static Animal getAnimal(String type) {
        return type.equals("dog") ? new Dog() : new Cat();
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a1 = Animals.getAnimal("dog");
        Animal a2 = Animals.getAnimal("cat");
        a1.speak();
        a2.speak();
    }
}
```

➡️ Method returns `Animal` but can choose any implementation (`Dog`, `Cat`).

---

## 2. Hiding implementation classes for a cleaner API

Static factory methods allow you to return objects whose classes are **not public**, reducing API size.

### Interface
```java
public interface Shape {
    double area();

    static Shape circle(double radius) {
        return new Circle(radius);
    }
}

### Package-private implementation (hidden)

class Circle implements Shape {
    private final double radius;

    Circle(double radius) {
        this.radius = radius;
    }

    public double area() {
        return Math.PI * radius * radius;
    }
}

### Usage

Shape s = Shape.circle(5);
System.out.println(s.area());
```

➡️ User never sees the `Circle` class.
➡️ The API stays small and easy to understand.

---

## 3. How Java Collections uses this

Before Java 8, interfaces couldn’t have static methods.
So the JDK used a **non-instantiable companion class**: `java.util.Collections`.

Example:

List<String> unmodifiable = Collections.unmodifiableList(list);

Internally, JDK returns a nonpublic class:

private static class UnmodifiableList<E> implements List<E> {
    // hidden implementation
}

➡️ Avoided exposing 45+ implementation classes.
➡️ API becomes smaller and conceptually simpler.

---

## 4. Modern Java (Java 8+)

Interfaces can now have static methods:

public interface Car {
    static Car electric() {
        return new ElectricCar();
    }
}

But note:

* static methods in interfaces must be public
* static fields and static nested classes must also be public
* actual implementation classes (like ElectricCar) can still be hidden

---

# Summary

Static factory methods:
* reuse objects (caching)
* have meaningful names
* can return any subtype
* can hide implementation classes
* create smaller, cleaner APIs
* encourage programming to interfaces
