# Override `clone()` Judiciously --- Effective Java Summary

## Why `Cloneable` Is Flawed

-   `Cloneable` is a marker interface with no methods.
-   It only changes the behavior of `Object.clone()`.
-   Design is considered broken and unintuitive.

## Problems with `clone()`

### 1. Shallow Copy by Default

-   Primitives are copied.
-   Object references are shared.
-   Leads to bugs and shared mutable state.

### 2. Constructors Are Bypassed

-   Initialization logic is skipped.
-   Validation and invariants may break.

### 3. Subclassing Issues

-   Subclasses must manually deep-clone new fields.
-   Must carefully call `super.clone()`.
-   Error-prone and difficult to maintain.

## Better Alternatives

### ✔ Copy Constructor

``` java
public Person(Person other) {
    this.name = other.name;
    this.age = other.age;
}
```

### ✔ Copy Factory

``` java
public static Person copyOf(Person other) {
    return new Person(other);
}
```

## When `clone()` *Is* Acceptable

-   When subclassing a class that already properly implements Cloneable.
-   When performance-critical simple structures (like arrays) need quick
    copying.

## Recommended `clone()` Pattern (If You Must Use It)

``` java
@Override
public MyClass clone() {
    object[] test;
    try {
        MyClass cloned = (MyClass) super.clone();
        cloned.test= test.clone();
        // Deep copy mutable fields manually
        return cloned;
    } catch (CloneNotSupportedException e) {
        throw new AssertionError(); // Should not happen
    }
}
```

## Final Summary

-   Avoid `Cloneable` in new designs.
-   Prefer **copy constructors** or **copy factories**.
-   Override `clone()` only when required by an existing hierarchy.
