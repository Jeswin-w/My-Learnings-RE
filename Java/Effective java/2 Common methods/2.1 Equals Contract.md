# Obey the Contract When Overriding `equals` (Effective Java Summary)

Overriding `equals` is necessary when creating value-based classes.
However, doing it incorrectly can violate the general contract of
`equals`, leading to unpredictable bugs. Effective Java emphasizes
strictly following the contract defined in the Java specification.

------------------------------------------------------------------------

## When You Should Override `equals`

Override `equals` **only if**: - Logical equality is needed (not just
reference equality) - Instances represent values (e.g., `Integer`,
`String`, `BigDecimal`, coordinate pairs)

Do **not** override `equals` if: - Each instance is unique (e.g.,
Thread) - The class is immutable and logical identity is the same as
object identity (e.g., enums) - The class is private/internal and
equality is never checked

If you are going to use contains of a collection you need to implement equals

------------------------------------------------------------------------

# The `equals` Contract

Your implementation **must** satisfy all five conditions:

## 1. **Reflexive**

For any non-null reference:

``` java
x.equals(x) == true
```

Object must equal itself.

## 2. **Symmetric**

For any non-null references:

``` java
x.equals(y) == y.equals(x)
```
imagine you have a class caseinsensitiveString which can be equal to a string.
but a string will never be equal to a caseinsensitivestring.

Both sides must agree.

## 3. **Transitive**

For any non-null references:

    if x.equals(y) and y.equals(z) then x.equals(z)

you can even make a infinite loop if you have 2 sub classes that does not override equals.

in these cases dont go for inheritance instead go for composition.

```java
//color point
@Override
public boolean equals(Object o) {
    if (!(o instanceof Point)) return false;

    if (!(o instanceof ColorPoint))
        return o.equals(this);     // <-- problematic

    ColorPoint cp = (ColorPoint) o;
    return super.equals(o) && color.equals(cp.color);
}

//smell point 
@Override
public boolean equals(Object o) {
    if (!(o instanceof Point)) return false;

    if (!(o instanceof SmellPoint))
        return o.equals(this);     // <-- problematic

    SmellPoint sp = (SmellPoint) o;
    return super.equals(o) && smell.equals(sp.smell);
}
```
o.equals(this) will result in infinite recursion.

Critical for sets, maps, sorting, and collections logic.

## 4. **Consistent**

Multiple invocations must be consistent *as long as the objects don't
change*.

## 5. **Non-nullity**

``` java
x.equals(null) == false
```

------------------------------------------------------------------------

# How to Implement `equals` Correctly

Effective Java recommends following this standard recipe:

### ✔ Step 1: Use `==` to check if both references are the same

``` java
if (this == obj) return true;
```

### ✔ Step 2: Return false if the other object is not the same type

Use either: - `instanceof` (more flexible), or - `getClass()` (for final
classes or strict type equality)

### ✔ Step 3: Cast to the correct type

``` java
MyClass other = (MyClass) obj;
```

### ✔ Step 4: Compare all significant fields

For example:

``` java
return Objects.equals(name, other.name)
    && age == other.age;
```

### ✔ Step 5: Ensure fields used in equality are consistent with `hashCode`

Otherwise, HashMap/HashSet will behave incorrectly.

------------------------------------------------------------------------

# Common Pitfalls to Avoid

### ❌ Failing symmetry when mixing inheritance

Example: A subclass adds fields → breaks symmetry.\
Solution: Do **not** use inheritance for value-based classes. Use
composition instead.

### ❌ Including fields in `equals` but not in `hashCode`

Breaks HashMap and HashSet behavior.

### ❌ Comparing floating-point types directly

Use:

``` java
Float.compare(f1, f2)
Double.compare(d1, d2)
```

### ❌ Allowing mutable fields in equality

Mutating fields that determine equality leads to unpredictable
collection behavior.

------------------------------------------------------------------------

# Example of a Correct `equals` Implementation

``` java
public final class Point {
    private final int x;
    private final int y;

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Point)) return false;
        Point other = (Point) obj;
        return x == other.x && y == other.y;
    }

    @Override
    public int hashCode() {
        return 31 * x + y;
    }
}
```

------------------------------------------------------------------------

# Summary

-   Override `equals` **only when necessary**.
-   Follow the **five-part contract** strictly: reflexive, symmetric,
    transitive, consistent, non-null.
-   Implement using the standard recipe from Effective Java.
-   Ensure consistency with `hashCode`.
-   Avoid pitfalls related to inheritance, floating-point comparison,
    and mutable fields.

Violating the contract can break entire data structures---following it
ensures correctness across Java collections and the language itself.
