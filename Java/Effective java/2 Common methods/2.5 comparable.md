# Effective Java ‚Äì Consider Implementing `Comparable`

> **Item:** Consider implementing `Comparable`

---

## Why Implement `Comparable`?

Implementing `Comparable<T>` indicates that instances of your class have a **natural ordering**. This enables seamless integration with core Java APIs:

- `Collections.sort(...)`, `Arrays.sort(...)`
- Sorted collections: `TreeSet`, `TreeMap`
- Utility algorithms that rely on ordering (binary search, min/max)

If your class has a clear, intuitive order (numbers, dates, names, value objects), it should usually implement `Comparable`.

---

## The `Comparable` Interface

```java
public interface Comparable<T> {
    int compareTo(T o);
}
```

### Return Value Semantics

- **Negative** ‚Üí `this < o`
- **Zero** ‚Üí `this == o`
- **Positive** ‚Üí `this > o`

---

## The `compareTo` Contract

A correct implementation must obey the following rules:

### 1. Symmetry

```text
sgn(x.compareTo(y)) == -sgn(y.compareTo(x))
```

If `x` is greater than `y`, then `y` must be less than `x`.

---

### 2. Transitivity

```text
If x > y and y > z, then x > z
```

Violating transitivity breaks sorted collections like `TreeSet` and `TreeMap`.

---

### 3. Consistency

```text
Repeated calls to compareTo return the same result
```

As long as the objects being compared do not change.

---

### 4. Consistency with `equals` (Strongly Recommended)

```text
(x.compareTo(y) == 0) == x.equals(y)
```

This is **not required**, but strongly advised.

‚ùó If violated:
- `HashSet` and `TreeSet` may behave differently
- Elements may disappear in sorted collections

---

## Example: Classic Field-by-Field Comparison

```java
@Override
public int compareTo(PhoneNumber pn) {
    int result = Short.compare(areaCode, pn.areaCode);
    if (result == 0) {
        result = Short.compare(prefix, pn.prefix);
        if (result == 0) {
            result = Short.compare(lineNumber, pn.lineNumber);
        }
    }
    return result;
}
```

‚úî Correct
‚úî Transitive
‚úî No arithmetic subtraction (avoids overflow)

---

## Preferred Java 8+ Style: Comparator Helpers

```java
private static final Comparator<PhoneNumber> COMPARATOR =
    Comparator.comparingInt((PhoneNumber pn) -> pn.areaCode)
              .thenComparingInt(pn -> pn.prefix)
              .thenComparingInt(pn -> pn.lineNumber);

@Override
public int compareTo(PhoneNumber pn) {
    return COMPARATOR.compare(this, pn);
}
```

### Advantages

- More readable
- Less error-prone
- Easy to extend

---

## What NOT to Do

### ‚ùå Don‚Äôt Use Subtraction

```java
// WRONG
return this.age - other.age;
```

Reason:
- Integer overflow
- Violates `compareTo` contract

---

### ‚ùå Don‚Äôt Make Ordering Inconsistent

Changing comparison logic across calls breaks sorted collections.

---

## When NOT to Implement `Comparable`

- No clear natural ordering
- Multiple equally valid orderings
- Ordering depends on external state

üëâ Use `Comparator` instead.

---

## Comparable vs Comparator

| Comparable | Comparator |
|-----------|------------|
| Natural order | External order |
| Implemented by class | Separate object |
| One per class | Many possible |

---

## Summary

- Implement `Comparable` for value classes with a natural order
- Follow **symmetry**, **transitivity**, and **consistency**
- Prefer consistency with `equals`
- Use `Comparator` helper methods (Java 8+)
- Avoid subtraction-based comparisons

---

üìò *Effective Java, 3rd Edition ‚Äì Josh