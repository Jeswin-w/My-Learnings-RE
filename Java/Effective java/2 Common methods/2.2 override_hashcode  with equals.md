# Overriding hashcode when we override equals
WHen we override equals we need to also override hashcode methods

because we need 2 objects that are equal to give same hashcoode for then for hashmap and hashset 

# Java hashCode() Implementation Methods

## 1. Standard 31-Multiplier Pattern (Recommended)

```java
result = Short.hashCode(areaCode);
result = 31 * result + Short.hashCode(prefix);
result = 31 * result + Short.hashCode(lineNum);
```

### Why this pattern?
- 31 is an odd prime → helps reduce collisions.
- JVM optimizes 31 * x as (x << 5) - x.
- Produces well-distributed hash values.
- Standard from Effective Java.

---

## 2. Using Objects.hash(...) (Simplest, but slower)

```java
@Override
public int hashCode() {
    return Objects.hash(areaCode, prefix, lineNum);
}
```

### Pros
- Short, clean code.
- Easy to maintain.

### Cons
- Allocates an array internally → slower.
- More collisions than the 31-pattern.

---

## 3. Using Arrays.hashCode(...)

```java
@Override
public int hashCode() {
    return Arrays.hashCode(new short[]{ areaCode, prefix, lineNum });
}
```

### Pros
- Very compact.

### Cons
- Allocates a new array every call → slow.
- Not advised for performance-critical paths.

---

## 4. Using Java Records (Java 16+)

```java
public record PhoneNumber(short areaCode, short prefix, short lineNum) {}
```

### Pros
- Java auto-generates hashCode().
- Zero maintenance.

### Cons
- Only for Java 16+ and if you can use records.

---

## 5. Using External Library (Guava)

```java
@Override
public int hashCode() {
    return com.google.common.base.Objects.hashCode(areaCode, prefix, lineNum);
}
```

### Pros
- Clean and readable.

### Cons
- External dependency required.

---

## 6. Custom Prime-Based Hash Combining

```java
@Override
public int hashCode() {
    int h = 1;
    h = h * 17 + areaCode;
    h = h * 17 + prefix;
    h = h * 17 + lineNum;
    return h;
}
```

### Pros
- Fully customizable.

### Cons
- Easy to choose bad parameters → collisions.
- Less reliable than standard patterns.

---

## Recommendation

| Approach | Best For |
|---------|----------|
| **31-multiplier pattern** | Best performance + low collision rate |
| **Objects.hash(...)** | Clean code; perf not critical |
| **Records** | Modern Java; auto-generated correctness |
| **Custom primes** | Special tuning cases |
| **Guava** | If already using Guava |

