# Kotlin Annotations – Practical Guide

## What are Annotations?

Annotations attach **metadata** to code.  
They do **not execute logic** by themselves, but are used by:

- Dependency Injection frameworks
- Validation frameworks
- Compilers
- Build tools
- Reflection-based libraries

```kotlin
annotation class Fancy
```

---

## Where Annotations Are Commonly Used

### 1. Dependency Injection (DI)

Used by frameworks like Dagger, Hilt, Spring, Guice.

```kotlin
class Foo @Inject constructor(dep: MyDependency)

class Bar {
    var dep: MyDependency? = null
        @Inject set
}
```

**Use when:** wiring dependencies automatically.

---

### 2. Validation & Constraints

Used in DTOs, REST APIs, forms.

```kotlin
data class User(
    @Email val email: String,
    @NotNull val name: String
)
```

**Use when:** validating user input or API payloads.

---

### 3. Framework Configuration

Annotations define behavior in frameworks.

```kotlin
@Test fun testSomething()
@GetMapping("/users")
@Entity class User
```

---

## Kotlin vs Java Annotations – Key Differences

### Property vs Field

**Java**
```java
@Email
private String email;
```

**Kotlin**
```kotlin
@field:Email val email: String
```

---

## Common Annotation Mistakes in Production

1. Missing use-site targets  
2. Using field injection instead of constructor injection  
3. Wrong retention level  
4. Overusing annotations for business logic  
5. Assuming Java and Kotlin behave identically  

---

## Final Rule of Thumb

> **Annotations describe structure and intent — not behavior.**
