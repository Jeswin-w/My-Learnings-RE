
# Kotlin Keywords and Operators 

## Hard Keywords

Hard keywords are **always reserved** and cannot be used as identifiers.

---

## `as` and `as?` — Type Casting

### What it does
Converts a value from one type to another.

- `as` → Unsafe cast (throws exception if cast fails)
- `as?` → Safe cast (returns `null` if cast fails)


```kotlin
val value: Any = "abc"

val text: String = value as String       // OK
val safeText: String? = value as? String // Preferred
```

❌ Bad practice:
```kotlin
val num: Int = value as Int // Runtime crash
```

---

## `break` and `continue` — Loop Control

### What it does
- `continue` skips the current iteration
- `break` exits the loop

### When to use
- Early exit from loops
- Skipping invalid values

### When NOT to use
- Avoid deep nested loops with many `break`s
- Prefer higher-order functions like `filter`, `map`

```kotlin
for (i in 1..5) {
    if (i == 2) continue
    if (i == 4) break
    println(i)
}
```

---

## `class`, `interface`, `object`

### `class`
Use when:
- You need state and behavior
- Multiple instances required

### `interface`
Use when:
- Defining a contract
- Supporting multiple inheritance

### `object`
Use when:
- Exactly one instance is needed (Singleton)
- Stateless utility holder

```kotlin
object AppConfig {
    const val VERSION = "1.0"
}
```

❌ Avoid `object` when:
- You need dependency injection
- You need multiple instances

---

## `if`, `else`, `when`

### What it does
In Kotlin, these are **expressions** (they return values).

### When to use `if`
- Simple conditions

### When to use `when`
- Multiple conditions
- Replacing `switch`

```kotlin
val result = if (x > 5) "Big" else "Small"
```

❌ Avoid long chained `if-else`
Prefer `when`.

---

## `for`, `while`, `do`

### `for`
- Preferred for collections

### `while`
- Condition-based looping

### `do-while`
- When body must run at least once

❌ Avoid infinite loops without exit conditions.

---

## `is` and `!is` — Type Checks

### What it does
Checks type at runtime with smart casting.

### When to use
- Handling mixed types
- `when` expressions

```kotlin
if (value is String) {
    println(value.length) // Smart cast
}
```

❌ Avoid excessive type checks — indicates poor design.

---

## `try`, `catch`, `finally`, `throw`

### When to use
- Recoverable errors
- Parsing, IO, validation

### When NOT to use
- Normal control flow

```kotlin
try {
    val n = input.toInt()
} catch (e: NumberFormatException) {
    println("Invalid number")
}
```

---

## `val` vs `var`

### Best Practice Rule
> **Always use `val` unless mutation is required**

### Why?
- Thread-safe
- Predictable code

```kotlin
val name = "Alice"
var age = 20
age++
```

---

## Soft Keywords
In Kotlin, soft keywords are words that behave like keywords only in specific contexts.
Outside those contexts, they can still be used as normal identifiers (variable names, function names, etc.).

This is different from hard keywords, which are always reserved.

---

## `by` — Delegation

### What it does
Delegates implementation to another object. ie) the implementation is of logger class does not have its own implementation

### When to use
- Composition over inheritance
- Cleaner code

### When NOT to use
- When behavior needs modification

```kotlin
class Service(logger: Logger) : Logger by logger
```

---

## `constructor` and `init`

### `init`
- Runs immediately after object creation

### When NOT to use
- Heavy logic or IO

```kotlin
class User(val name: String) {
    init {
        require(name.isNotEmpty())
    }
}
```

---

## Modifier Keywords

---

## `data`

### When to use
- DTOs
- Immutable data holders

### When NOT to use
- Entities with behavior-heavy logic

---

## `sealed`

### When to use
- Restricted class hierarchies
- State machines

```kotlin
sealed class Result
```

---

## `open`, `override`, `final`

### Kotlin philosophy
> Classes are `final` by default

### When to open
- Framework extension points

---

## `inline` and `reified`

### When to use
- Small functions
- Performance-sensitive lambdas

❌ Avoid inlining large functions.

---

## `suspend`

### When to use
- Long-running or async tasks

### When NOT to use
- CPU-heavy synchronous work

---

## Special Identifiers

---

## `field`

### When to use
- Custom getters/setters

❌ Do NOT access `field` outside accessors.

---

## `it`

### When to use
- Single-parameter lambdas

❌ Avoid when clarity suffers.

---

## Operators

---

## `==` vs `===`

### Use `==`
- Almost always

### Use `===`
- Reference comparison only

---

## Null Safety Operators

### `?.`
Use when value may be null

### `!!`
❌ Avoid unless absolutely sure

---

## Interview Golden Rules

- Prefer `val`
- Avoid `!!`
- Prefer composition (`by`) over inheritance
- Use `sealed` instead of enums when behavior differs
- Avoid excessive casting and type checks

---

