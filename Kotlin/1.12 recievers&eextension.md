# Kotlin: Receivers and Extensions — Notes

## Introduction
Kotlin supports functions that are invoked on objects using **receivers**. This concept enables
clean APIs and makes **extension functions** possible.

This document summarizes:
- receivers
- extension functions
- nullable receivers
- extension properties

Based on: https://typealias.com/start/kotlin-receivers-and-extensions/

---

## Standalone Functions vs Object Functions

Standalone function:
```kotlin
fun singleQuoted(original: String) = "'$original'"
```

Object function:
```kotlin
"hello".uppercase()
```

Object-style calls enable chaining and readability.

---

## Receivers

The **receiver** is the object on the left side of the dot.

```kotlin
"hello".length
```
Here, `"hello"` is the receiver.

Receivers allow functions to behave like object methods without modifying the class.

---

## Extension Functions

Extension functions add new behavior to existing types.

```kotlin
fun String.singleQuoted(): String = "'$this'"
```

Usage:
```kotlin
val name = "Kotlin"
println(name.singleQuoted())
```

### Important Characteristics
- Resolved at **compile time**
- Do **not** support runtime polymorphism
- Compiled into static methods

---

## Static Resolution Example

```kotlin
open class A
class B : A()

fun A.foo() = "A"
fun B.foo() = "B"

val obj: A = B()
println(obj.foo()) // Output: A
```

Extensions depend on **declared type**, not runtime type.

---

## Nullable Receivers

Extensions can be defined on nullable types.

```kotlin
fun String?.safeLength(): Int {
    return this?.length ?: 0
}
```

Usage:
```kotlin
val text: String? = null
println(text.safeLength())
```

---

## Extension Properties

Extension properties provide computed values.

```kotlin
val String.lastChar: Char
    get() = this[length - 1]
```

Usage:
```kotlin
println("Kotlin".lastChar)
```

### Notes
- No backing field
- Getter only

---

## When to Use Extensions

✔ Utility functions  
✔ Cleaner APIs  
✔ Enhancing Java libraries  

## When Not to Use Extensions

✘ When polymorphism is required  
✘ When behavior must vary by subclass  

---

## Summary

- Receivers enable dot-call syntax
- Extension functions do not modify classes
- Resolution is static
- Nullable receivers increase safety
- Extension properties are computed-only

---
